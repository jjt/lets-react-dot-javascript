<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Let's React Dot Javascript</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

      <section class="center">
        <h1>Let's React dot Javascript!</h1>
        By Jonathan Taylor Thomas
        <pre style="display:none"><code>Needless pre/code block for highlight.js... wheee!!</code></pre>
      </section>



      <section data-markdown>
        <script type="text/template">
# About React
        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
## React is...
<ul>
<li>An open-source JS library for building UIs</li>
<li class="fragment">Used as the V in MV* (standalone or with other frameworks)</li>
<li class="fragment">15,500 GH stars, nearly 300 contributors</li>
<li class="fragment">Made by Facebook and used in production</li>
</ul>

<span class="fragment"><strong>
But! it is not a framework (Angular, Ember, etc)
</strong></span>
        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
## Why React?
<ul>
<li> Makes data flow and application state explicit </li>
<li class="fragment"> React components are easy to reason about </li>
<li class="fragment"> Small API surface area </li>
<li class="fragment"> Performance (JS is fast, the DOM is a world of sadness) </li>
<li class="fragment"> Server-side rendering (isomorphic applications) </li>
</ul>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
# React Components
        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
## About components
* Components ecapsulate data, behaviour, and markup
* Nestable, composable <!-- .element: class="fragment" -->
<li class="fragment"> Component data is _properties_ and _state_</li>
<li class="fragment"> Whenever _props_ or _state_ change, component(s) re-render</li>
* Efficient renders due to virtual DOM + diffing <!-- .element: class="fragment" -->


        </script>
      </section>





      <section data-markdown>
        <script type="text/template">
## A simple React component
A minimal component simply implements a `render` method:
```js
var SimpleComponent = React.createClass({
  render: function() {
    return <div>I'm a simple component</div>;
  }
});

React.render(<SimpleComponent/>, $("#app"));
```

This will render the following markup into `#app`:
```
<div>I'm a simple component</div>
```

There's more to React components, but first... <!-- .element: class="fragment" -->
        </script>
      </section>



      <section data-markdown class=center>
        <script type="text/template">
#MARKUP IN JS?!?!?!???
![](http://i.imgur.com/WB7I8I3.jpg)
        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
## JSX: Javascript + HTML
Extends JS with an HTML-like syntax and gets compiled from this:

```js
var SimpleComponent = React.createClass({
  render: function() {
    return <div>I'm a simple component</div>;
  }
});
React.render(<SimpleComponent/>, $("#app"));
```

Into pure JS:

```js
var SimpleComponent = React.createClass({
  displayName: "SimpleComponent",
  render: function() {
    return React.createElement("div", null, "I'm a simple component");
  }
});
React.render(React.createElement(SimpleComponent, {},), $("#app"));
```

        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
## Advantages of using JSX

* Near-identical to HTML (familiarity, matches rendered output)
<li class="fragment" data-fragment-index=1> Less verbose/clunky syntax
<li class="fragment" data-fragment-index=3> Takes care of boilerplate (ex. `React.createElement` calls)</li>
<li class="fragment" data-fragment-index=5> [CJSX](https://github.com/jsdf/coffee-react) for JSX + CoffeeScript, or [6to5](https://github.com/6to5/6to5) for JSX + ES6</li>

<p class="fragment" data-fragment-index=10>
  __Disadvantages__: looks weird, needs compilation. You get used to the look, and most people use build tools anyway (Gulp, Grunt, Webpack, etc)
</p>

<p class="fragment" data-fragment-index=10>[More info on JSX](http://facebook.github.io/react/docs/jsx-in-depth.html), and some [gotchas](http://facebook.github.io/react/docs/jsx-gotchas.html)</p>
        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
# Back to components...
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">
## Component properties

Component _properties_ are passed in like HTML attributes, should be treated
as immutable after component instantiaion

```
var Person = React.createClass({
  render: function() {
    return <div>{this.props.greeting} My name is {this.props.name}</div>;
  }
});

React.render(<Person name="Bertie" greeting="Hullo!"/>, $("#app"));
```
Renders:
```html
<div>Hullo! My name is Bertie</div>
```
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">
## Default properties
Define `getDefaultProps` method that returns an object
```
var Person = React.createClass({
  getDefaultProps: function() {
    return { greeting: "Hi." };
  },
  render: function() {
    return <div>{this.props.greeting} My name is {this.props.name}</div>;
  }
});

React.render(<Person name="Defaultio"/>, $("#app"));
```
Renders:
```html
<div>Hi. My name is Defaultio</div>
```
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">
## Property validation
Development-time propery checks ([lots of them](http://facebook.github.io/react/docs/reusable-components.html#prop-validation))
```js
Person = React.createClass({
  propTypes: {
    name: React.proptypes.string.isRequired, //Required
    greeting: React.proptypes.string //Optional
  },
  //...
});

React.render(<Person/>, $("#app"));
React.render(<Person name={true}/>, $("#app"));
```
Console log:
```
Warning: Required prop `name` was not specified in `Person`.
Warning: Invalid prop `name` of type `boolean` supplied to `Person`, expected `string`.
```
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">
## Component state
Mutable data, should only be modified by component itself
```js
var PersonWithStomach = React.createClass({
  getInitialState: function() {
    return: {
      isHungry: true
    }
  },
  render: function() {
    return <div>
              My name is {this.props.name} and I
              { this.state.isHungry ? "would love some food" : "am full, thanks" }
            </div>;
    }
});

React.render(<PersonWithStomach name="Bertie"/>, $("#app"));
```
Renders:
```html
<div>My name is Bertie, and I would love some food</div>
```

        </script>
      </section>








      <section data-markdown>
        <script type="text/template">
## Component state (cont)
Can access properties in `getInitialState`, but should do so sparingly and make explicit
that it's just the initial state (often a code smell)
```js
var PersonWithStomach = React.createClass({
  getInitialState: function() {
    return: {
      isHungry: this.props.isHungryInitial ? true : false
    }
  },
  render: function() { /* see previous */ }
});

React.render(<PersonWithStomach name="Bertie" isHungryInitial={false}/>, $("#app"));
```
Renders:
```html
<div>My name is Bertie and I am full, thanks</div>
```
        </script>
      </section>








      <section data-markdown>
        <script type="text/template">
## Props vs state
* Best to keep components stateless and pass things down as props 
* Getting new props or mutating state will automatically re-render
* A component's props should be treated as immutable, state is mutable but only by
that component
* Keep state where it makes sense (sometimes localised, sometimes at top app level)
* Facebook often uses stateful wrapper components to track pieces of app state
and pass them as props into stateless components
        </script>
      </section>







      <section data-markdown>
        <script type="text/template">
## Mutating state, component events
User events good candidates for state mutation with `this.setState()`

```js
var PersonWithStomach = React.createClass({
  getInitialState: function() { return {isHungry: this.isHungryInitial ? true : false} },
  handleClick: function() {
    this.setState({isHungry: !this.state.isHungry}); // Toggle isHungry
  },
  render: function () {
    return <div onClick={this.handleClick}>
              My name is {this.props.name} and I
              { this.state.isHungry ? "would love some food" : "am full, thanks" }
            </div>;
  }
});
React.render(<PersonWithStomach name="Bertie"/>, $("#app"));
```
Renders:
```html
<div>My name is Bertie and I would love some food</div>
<!-- click on the div, then it would be... -->
<div>My name is Bertie and I am full, thanks</div>
```

        </script>
      </section>





      <section data-markdown>
        <script type="text/template">
##Component lifecycle methods
Called at certain points, useful as hooks ([more info here](http://facebook.github.io/react/docs/component-specs.html))

<div class="fragment">
Initial rendering of a component (called in order):
<pre><code class="js hljs">getDefaultProps     // Default props
getInitialState     // Return obj representing initial state, can access this.props
componentWillMount  // Before initial render
render              // Initial render
componentDidMount   // After initial render (ex. init jQuery plugin)</code></pre>
</div>

<div class="fragment">
On change of _props_ or _state_ (called in order):
<pre><code class="js hljs">componentWillReceiveProps(obj nextProps)             // Only if props change
shouldComponentUpdate(obj nextProps, obj nextState)  // Return false to abort re-render
componentWillUpdate(obj nextProps, obj nextState)    // Do things right before re-render
render                                               // Re-render component
componentDidUpdate(obj prevProps, obj prevState)     // Re-trigger any DOM code (jQ plugs)
</code></pre>
</div>

<div class="fragment">
When component leaves the DOM, `componentWillUnmount` is called
</div>
        </script>
      </section>







      <section data-markdown>
        <script type="text/template">
## Nested Components

Components can include other components:
```
var GroupOne = React.createComponent({
  render: function() {
    return
      <div>
        <Person name="Bertie"/>
        <Person name="Jeeves" greeting="Sir?"/>
      </div>;
  }
});
React.render(<GroupOne/>, $("#app"));
```
Renders:
```html
<div>
  <div>Hullo! My name is Bertie</div>
  <div>Sir? My name is Jeeves</div>
</div>
```
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">
## Nested Components (cont)
Components can also render their children:
```
var GroupTwo = React.createComponent({
  render: function() {
    return <div>{this.props.children}</div>;
  }
});
React.render(
  <GroupTwo>
    <Person name="Bertie" greeting="Hullo!"/>
    <Person name="Jeeves" greeting="Sir?"/>
  </GroupTwo>,
  $("#app")
);
```
Renders:
```html
<div>
  <div>Hullo! My name is Bertie</div>
  <div>Sir? My name is Jeeves</div>
</div>
```

        </script>
      </section>



      <section data-markdown>
        <script type="text/template">
##Nested Components (cont)
Or by passing data through a property:
```js
var GroupThree = React.createComponent({
  getDefaultProps: function() { return {people: []} },
  render: function() {
    return
      <div>
        {this.props.people.map(function(personData, i) {
          return <Person {...personData} key={personData.name}/>;
        })}
      </div>;
  }
});
var people = [{name: "Bertie"}, {name: "Jeeves", greeting: "Sir?"}];
React.render(<Group people={people} />, $("#app"));
```
Renders:
```html
<div>
  <div>Hullo! My name is Bertie</div>
  <div>Sir? My name is Jeeves</div>
</div>
```
        </script>
      </section>




      <section data-markdown>
        <script type="text/template">


        </script>
      </section>






      <section data-markdown>
        <script type="text/template">


        </script>
      </section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: false,
				progress: true,
				history: true,
				center: true,
        width: 1280,
        margin: 0.1,


				transition: 'slide', // none/fade/slide/convex/concave/zoom
        transitionSpeed: 'fast',

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
